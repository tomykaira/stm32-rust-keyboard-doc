「はじめに」で自分でキーボード基板を引くのが主題のひとつであると説明しました。
この章では実際にどのようにしてキーボードハードウェアを製造するべきだったかを解説します。
実際にこのとおり手順よくできたわけではなく、多くの回り道と失敗がありました。
たんなる手順書にとどまらず、今後STM32をつかった自作キーボード基板を設計する人ができるだけスムーズに成功できるためのヒントを書くようにしました。

なお、かならずしもRust Firmwareを動かすために自分で基板をつくる必要はありません。
ブレッドボードを使ったり、既存のキーボード基板をつかってもよいです。
ハードウェアの章とソフトウェアの章は独立の問題をあつかっています。

# 部品の調達

キーボード基板を作ろうと思ったとき、KiCADなど基板を開くところから始めるのはせっかちです。
KiCADで回路を組み立てる前にどんな構成にするか決めるほうがよいです。
とくにMCUを自由に選定すると選択肢があまりに多く、またどれを使うかによって必要な周辺パーツもかわってきます。
まずやりたいことを整理し、MCUを決定するところから始めるのが余計なパーツを買って後悔しないコツです。

MCUを選び始める前に、価格についての考えを示します。
MCUの価格の許容範囲は生産数で変わります。
千台売る予定があるのであれば300円のMCUと200円のMCUはそこそこの違いになりますが、5個であれば無視できます。
基板1枚の製造コストはおおむね4ドルから5ドル(5枚で20ドルから30ドル)のようです。
また周辺部品を使い切れる分くらい購入するとしめて200円から500円くらいになります。
これらと比較してMCUは500円以内程度であれば機能リッチでトラブルが起きづらいものを選択する方針としました。
他の部分でも、価格よりはリスクや手間をケチるようにしています。
わたしたちの時間もタダではないし、ミスってやりなおしになったらそのぶん追加部品の費用もかかります。
どれくらいのパーツをつかうかは自由ですが、あらかじめどれくらいの幅におさめるか決め、値段にひきづられないのが即決のコツです。

やりたいことをリストアップしてみましょう。
キーボードは通常コンピュータなどUSBホストにUSB接続します。
USB接続機能が必要です。
USB接続は、原理的にはGPIOをつかってソフトウェア制御で実現できますが、おすすめしません。
USB機能をサポートしているハードウェアを選択するのが無難です。

次にキー数を見積もります。キーマトリクス方式の場合はGPIOがキー数のおよそ平方根ぶん、GPIO直結の場合はキー数分必要です。
どんなキーボードレイアウトにするかおおまかに想像し、必要なGPIO数があるMCUを選びます。

左右分離にするならば左右通信のための機能が必要です。
よく使われるのはI2CやUART、USARTです。
これもMCUがハードウェアサポートしている方がよいです。

わたしがとった構成はUSBとI2Cだけのシンプルなものですが、PS/2接続をつかったりアナログピンで静電容量を取ることももちろん可能です。
そのために必要な機能やピン数をしらべましょう。
Bluetoothをつかうこともできます。日本国内で使うならば技適準拠したMCUであり、かつ自分が実装したものも準拠するよう考慮する必要があります。

通信をソフトウェアエミュレーションするべきでない理由ですが、タイミングが非常に厄介になるからです。
たとえばUARTであれば一定の間隔で入力を読み取ったり出力を切り替える必要があります。
ソフトウェア実装するとこの間隔が非常にあやしくなりやすいです。1つだけの通信を実装するならまだしも、USBとI2Cなど複数の通信を実装するとタイミング制御が複雑になり、ファームウェアの実装難度が不必要にあがってしまいます。
たしかにハードウェア機能をつかうためにマニュアルを読むのも億劫ですが、少ないデバッグ時間で安定した動作を得るためにハードウェア機能を使うことを強くおすすめします。

最後に、ぜひおすすめしたいのがデバッグサポートとDFUです。
デバッグサポートとは特定のピンに外部ハードウェアを接続し、コンピュータなどから動作状況を調べられる機能です。
コンピュータ内のプログラミングで使うデバッガがそのまま開発中のハードウェアでも使えるイメージです。
本格的なデバッグツールは高価ですが、ST-Linkの機能を実装したノーブランド品なら500円程度で購入できます。
ハードウェアを上からながめていても何もわかりませんので、なんらか中身を見る方法があると安心です。
デバッグサポートはほとんどのMCUに存在します。
デバッグサポートのピンを空けておいても他の用途に使えることを確認しましょう。

DFU(USB DFU, Device Firmware Upgrade)はキーボードファームウェアをUSBで書き換える機能です。
わたしも調べる前はそんなの当然できるでしょと思っていましたが、STM32の、とくにMCU単体のものはできないものが多数あります。
有名どころでは、BluePillはできません。
STM32では上述のデバッガなどをつかって書き込むほうが一般的で、DFUサポートは限定的です。

また、非常に罠なのですが、MCUによってはDFUサポートがあると書いてあるにもかかわらず、使えないものがあります。
STM32F105/107がそうです。STM32F1シリーズは安価で販売している所も多いので、使えれば第一選択になるのですが、チップの版によっては使えません。
[STのAN2606](https://www.st.com/resource/en/application_note/cd00167594-stm32-microcontroller-system-memory-boot-mode-stmicroelectronics.pdf)から引用します。

> 14.3.2 Bootloader unavailability on STM32F105xx/STM32F107xx devices with date code lower than 937
> (中略)
> Workaround
> • For 64-pin packages
> None. The bootloader cannot be used. 

ひどい！この罠はしっかり踏みました。ひどすぎる。
いいかげんに購入したらどの版の石がくるかわからないので、こういうのは避けましょう。
AN2606はDFUサポートの優秀なMCUをみつくろうためにとても便利です。
各MCUのブートシーケンスが図示されているので、条件達成が容易そうなものをえらびましょう。

![STM32F105/107のブートローダーセレクション](https://i.ibb.co/y83vxtt/an2606-fig17.png)

たとえばこの図では、DFUにHSEが必要なことがわかります。
HSEとは外部クロックソースです(内部クロックソースがHSI)。
すなわちSTM32F105/107でDFUをつかうには発振子も実装する必要があります。
HSIでもDFUが使えるもののほうがいいですね。

コアの種類にも注意が必要です。
STM32はST社が制作する32-bit Arm Cortex-Mプロセッサコアを搭載したMCUの意味ですが、Cortex-Mのなかにも種類があります。
Cortex-M0からはじまり、M0+、M1、M3とつづきます。
おおむね数字がでかいほうが強いです。
離散フーリエ変換でライトをいいかんじに光らせたいとか特殊な希望がある場合はそれに適った性能のコアを選択しましょう。
またM0、M0+、M1はARMv6という古いインストラクションセットを採用しており、レジスタも端折られているので、ファームウェア実装で苦労します。
自力で書く分はともかく、ライブラリが動かないとかなり大変な目に遭うのでCortex-M3以上を搭載したものがオススメです。
この点がなければSTM32F072もよろしいのですが。
よりしょうもない話ですが、Rustで書くならば、HAL(Hardware Abstraction Layer)が実装されているか、更新されているかも気にする必要がありました。
[stm32-rs](https://github.com/stm32-rs)では製品ラインごとにHALをべつべつで実装していて、微妙にnaming conventionもずれていたりします。
F系が充実していますが後述の理由で回路が複雑になるので、ほかでマシそうなやつを探しました。
使いたいライブラリがあれば、対応状況を確認してください。

やりたいことと必要なものがきまったら実際の[MCU一覧](https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html)をみて選んでいきます。
以上でとりあげたのは次の項目です。

- USB DFU
- USB device
- I2Cなど
- キースイッチぶんのGPIO
- デバッグサポート(SWDIO,SWCLK)
- 演算性能

ほかに物理ピン数、パッケージ形式なども気にする必要があります。
手ハンダするならリードのあるもの(LQFP)を選択する必要があります。裏面パッドははんだゴテではんだ付けできないので詰みます。
物理ピン数は多すぎるとはんだ付けが面倒です。少なすぎるとGPIOが不足します。
RAMサイズ、Flashサイズはさほど気にする必要はないかと思います。複雑なことをしてRAM、Flashがたくさん必要なのでなければ入手性を優先してよいでしょう。

驚くべきことに、USB DFUの条件が一番厳しいのでこれで絞って、のこりの条件を満たすものを見つけるのがよいです。
STM32Fxxx系はすべてHSEを要求します。オシレータをのせたり回路を調べるのは面倒でしょう。
STM32G4xx、H4xx、H7xx、L4xx、L5xxはどうもHSIでのDFUをサポートしているようです。
正確にひとつずつみてはいないので、ねんのためAN2606で確認してください。

なおUSB DFUを要求せず、かわりにデバッガ(ST-Link等)相当の機能を基板上に実装することもできます。
NucleoなどSTM32を載せた開発ボードはたいていこのような構成になっています。
部品点数は増えますが、デバッグまでワンストップでできる利点があります。
わたしは最小部品数でやりたかったので、この方法は検討していません。

以上の条件を考え、わたしはDFUのあるなかでいちばん安そうでHALが動きそうだったSTM32L412を利用しました。
もちろんどれでもよいですが、STM32L412はすくなくとも問題なく動いているのでオススメです。

MCUを決めたらMCUが要求する回路を調査します。

部品を決めたら回路図を作成しつつ部品を購入します。
間違いがみつかるかもしれないので発注するのは回路図や基板が書けてからのほうがいいでしょう。
しかし入手性を確認する必要もあるので、どこでなにを買うのかは先に調べたほうがよかったです。
STM32の石はポピュラーなものはAliExpressやAmazonでも販売していますが、マイナーなものはMouserやDigiKeyに発注する必要があります。
どちらも海外発送で送料がたかいですが、6,000円以上で送料無料になるのである程度まとめて、ほかの部品も一気に購入しましょう。
必要数ギリギリに買うのはオススメできません。
小さい部品を紛失したり、はんだ付けに失敗するリスクはかなり高いです。
最低必要数の倍くらい購入しておくと安心です。
配送はかなり早いです。まず基板より先に到着します。

MCUを決めたらその周辺に配置する部品も決めねばなりません。
MCUが要求する部品もありますし、自分が作りたいキーボードの機能のために用意するものもあるでしょう。
たとえば左右分離する場合は通信ケーブルを接続する端子が必要です。
自作キーボードではTRRSケーブルを使っているものが多いです。
またキースイッチを直接はんだ付けするのか、キースイッチソケットを使うかといった判断もあります。

今回はMCUをSTM32L412C8に、左右の通信をI2Cに、Kailhのソケットを利用し、スイッチはGPIOとGNDの間に直接配置しキーマトリクスは使わない方針としました。
次の「回路図の作成」からはこの構成を念頭に書いていますので、異なる箇所は読み替えてください。

# 回路図の作成

回路図を書くには必要な部品を調べるところから始めましょう。
MCUやその他のキーボードの中心となる機能を担う部品はすでに決めました。
次はそれらの資料を確認しながら間を繋ぐ部品と接続の方法を調査します。
KiCADなど基板CAD上でそれらを実際に配置したら回路図の作成は完了です。

今回作成した回路図は次のとおりです。
ひとつずつ要素を分解して見ていきます。
理由を理解すればいずれもシンプルな回路です。

![flat-sch](flat-sch.png)

## MCUとUSB

ST社が回路設計のマニュアルを公開していますので、ここから始めましょう。
STM32L4の場合
[AN4555 Getting started with STM32L4 Series and STM32L4+ Series hardware development (PDF)](https://www.st.com/resource/en/application_note/dm00125306-getting-started-with-stm32l4-series-and-stm32l4-series-hardware-development-stmicroelectronics.pdf)
がドキュメント一覧にみつかります。

一番気をつけるべきは電源線(VCC、GND)の扱いとBOOT、Resetの結線です。
電源線が正しく実装されていないと動作が不安定になったり故障のリスクが増大します。
BOOTとResetが正しく用意されていないと一度アプリケーションを書き込んだらDFUに戻れなくなってしまうかもしれません。

マニュアルを見るといろいろ注意が書いてありますが、Reference designどおりにしておけばまず間違いはないでしょう。
実際に基板上に部品を配置するときの注意も各所に書いてあります。
各々参照するのが望ましいですが、まず全体像を把握しましょう。

いま参照している版では8.2がComponent referenceで、必要な要素が列挙されています。
Table 18. Mandatory componentsを見ると必須なのはMCUのほかいくつかのキャパシタだけのようです。
資料から引いた図でオレンジ色でかこった部分が必須のキャパシタです。
これらはdecoupling capacitor、すなわち相互の電源電圧に対する影響を排除する目的で挿入されるものです。

![Reference design](reference-design.png)

2.3 Power supply sequence between VDDA, VDDUSB, VDDIO2, VLCD and VDOをみるとVDDが1V以下に下がりうる場合はこれらの電圧にケアが必要であると記述されています。
しかし今回はキーボードであり、つねにコンピュータなどUSBホストから一定の電圧が給電される想定ですから、この部分は割愛してよいでしょう。
わたしの実装では簡略化してすべての電源を同等に扱い、電源ピンとGNDの間に0.1uFのキャパシタを挟みました。

![Reference design](my-vdd.png)

次に各VDDの電圧範囲を確認しましょう。
VDDUSBは電圧範囲が3.0Vから3.6Vで、一番タイトです。
ほかのVDDはこの範囲で動作します。
この電圧が狂うとUSB機能が正常動作しなくなります。
またUSBの生の電圧である5Vではありません。

キーボードをUSB接続するためにUSB端子を基板上に設置します。
端子はmicro-BでもUSB-Cでも、ここの電源線に来る電圧は+5Vです。
5Vをそのまま供給することはできませんし、端子には静電気や電圧の不安定が発生するリスクがありますので、これらの対策も必要です。

![Reference design](my-power.png)

電源をコントロールする目的でこのような電源回路を配置しました。
要素を順にみていきましょう。左のUSB_B_MicroがUSB端子です。ここにUSBケーブルが繋がります。
このなかでVBUSとGNDに注目しましょう。
GNDは直接基板全体のGND(GNDベタ)に接続されます。
VBUSはI2C用によけているのと、Polyfuseにはいっている線があります。
PolyfuseはResettable fuseとも呼ばれ、過剰な電流が流れたときに回路、特にMCUを保護します。
これがないと静電気などでMCUに過電流が流れ、破損するリスクがあります。
次に3.3Vのレギュレータ(U2)が来ます。
レギュレータは入力電圧から小さい、安定した出力電圧を作る部品です。
これのおかげでMCUに3.3Vの安定した電源が供給でき、上述の問題が解決されました。
レギュレータも左右にdecoupling capacitorを入れるよう指示されるものがほとんどです。
レギュレータの説明書にどれくらいの容量をいれればいいか記載しています。
最もコンパクトなものはIN、OUT、GNDの3ピンですが、このようにEN(Enable)やNC(Not connected)があるバーツもあります。
各ピンがどういう役割か説明書で確認しておきましょう。

レギュレータとPolyfuseは入手性のよいもの、はんだ付けのしやすいものを適当に選択しましょう。
スペックで重要なのはレギュレータであれば入力電圧範囲に5Vが含まれていること、出力電圧が3.0-3.6V内であることです。
Polyfuseであれば回路で要する電流にちょっと余裕があるくらいの、多すぎない電流で遮断が走るものをチョイスしましょう。
表面実装だからと気合をいれてやたらちっちゃいものを選ぶとはんだ付けがやたら大変です。
大きいものは逆に足が広くてはんだ付けしづらかったり、回路サイズが無駄に増えてしまいます。

電源の話題から逸れますが、USBLC6も解説します。
いままでは電源線の保護を考えましたが、USBの信号線、D+、D-も外部から来る線なので、静電気等の対策を行うべきです。
USBLC6はこのための部品です。
詳しい仕組みはカタログに記載がありますが、静電気対策のほかD+とD-(これらは通信中つねに反対の電位にあります)のバランスを調整します。
雰囲気で言えば信号をキレイにしてくれるものです。

## キースイッチ・マトリクス

キースイッチの選択はこの文書の範囲外ですが、あまりキースイッチを触ったことのない方のためにいくつか注意点を述べます。
回路図を描く段階ではスイッチはただの2端子の部品ですが、基板を起こす段階ではフットプリントを意識します。
キースイッチのフットプリントはスイッチによって異なります。
普及しているもの同士ではCherry MX互換品とKailh等のロープロファイル品が非互換です。
またスイッチソケットを利用する場合もソケットによってフットプリントが異なります。

基板を裏表で使えるようにすると思うならばさらに注意が必要です。
MCUを直載せする場合MCUの部分を両面に作るのは作業負担が大きく、短絡等のリスクも増大するので一方向のみで利用する設計がおすすめです。

裏表にするか、どのタイプのスイッチを使うか、ソケットを使うかを考慮してフットプリントを決定しましょう。
回路図の上ではスイッチを必要数並べるだけです。

1つのスイッチを1つのGPIOに対応づけるのか、キーマトリクスを構成するかが次の論点になります。
キーマトリクスとはキーボードをN行M列の行列とみなし、行に順に電圧をかけ、その間に列の電位を見ることでどのキーが押されているか特定する方法です。
i行に電圧をかけているときj列の電位変化があれば(i,j)の位置のキーが押されていると判断できます。
電圧をかける方向とセンシングする方向は逆でもかまいません。
1つのスイッチに1つのGPIOを対応づけると当然キー数ぶんの余剰GPIOが必要です。
この方法であれば行数+列数で済むので、最小キー数の平方根の倍のGPIOで済みます。

自作キーボードはProMicroを利用するものが多く、ProMicroのピン数は少なめなので、キーマトリクス方法を採用しているものが多いです。
キーマトリクスを採用する場合、誤検知を防ぐためダイオードを入れるべきです。
そのため目にする自作キーボードキットの多くはダイオードをたくさんはんだ付けする設計になっています。

MCU直載せであれば自由に足の数を選べるのでGPIO直結も可能です。
GPIO直結の利点は部品点数が節約できることの他に、キーに特殊な意味を持たせやすいこともあります。
GPIOと他の機能を切り替えられるピンにキースイッチを接続することでMCUのハードウェアに直接キー押下で指示を出せます。
スリープ解除、ブートモード切替などのユースケースが思いつきます。
ただし、足の数が増えることでICのサイズが大きくなるため基板上で配置できる場所に制約がかかる、基板設計で線を引き回すのが面倒というデメリットがあることも留意しましょう。

今回は直結を試してみました。
しかし実際につくってみるとやはりキー数が少なすぎたかなという感じもあります。
3Dプリントしたケースでキーの角度を調整したかったこと、大きい基板を発注するとお金がかかることから、一部キーをモジュール化し、MountingHoleで後から配線するシステムにしています。
最大25キー接続できますので3x7(4本指のゾーン)+4(親指ゾーン)、あるいは4x6+1をイメージしています。

![keys](switch-direct.png)
![mcu-bottom](mcu-bottom.png)

キーマトリクスの実装をする場合は原理を理解しスキャン方向をあらかじめ決定する必要があります。
ここで実装方法は解説しません。
[オリジナルキーボードを作ってみる その7「キーマトリックス」-ゆかりメモ](https://eucalyn.hatenadiary.jp/entry/original-keyboard-07)や[キーマトリックス](https://www.ei.fukui-nct.ac.jp/~t-saitoh/exp/h8/key-matrix.html)が参考になります。

## I2C用のTRRSジャック

左右分割キーボードの場合、左右のMCU同士の通信メカニズムが必要です。
通信メカニズムはMCUがサポートしているもののうち使い慣れているものということでI2Cを選択し、接続ケーブルはTRRSを使うことにしました。
なお、自作キーボードの慣習としてTRRSやI2Cを外部コンポーネントとの通信で使っていますが、この選択はかならずしもベストではありません。
キーボードは通信速度も信頼性の要求も低いので現実に動作しますが、設計面でよりよい選択肢はあるかもしれません。

模式図は次のようになります。
この構成は完全に左右対称です。
左右で同じ基板を使い回すことができます。

![trrs-abstract](trrs-abstract.png)

STM32L412はI2Cに利用できるピンを複数組提供していますが、ドキュメントの一番上に書いてあるもの、すなわちI2C1のパターン1を使うのが無難です。
データシート上ではAlternate Functionのなかで`I2C1_SCL`、`I2C1_SDA`などと記載されています。
STM32L412の場合PA9とPA10がこれに対応します。
このピンをTRRSジャックの足に接続します。

![i2c-mcu](i2c-mcu.png)

![i2c-trrs](i2c-trrs.png)

VCCとGNDはUSBから貰ったものをそのまま反対側に渡しています。
TRRSもジャックですので、静電気などの影響をうけることが予想されます。
そのため反対の基板でもヒューズやレギュレータを利用するべきと考えました。
信号線にも静電気対策をするべきですが、適当な回路がわからなかったので今回は対応しませんでした。

なお、このVCCとGNDの配列は問題があるかもしれません。
左右両方にUSBケーブルを接続した状態でTRRSを挿抜すると短絡が起きUSBが停止されるかコンピュータごとクラッシュすることがありました。
PC側で保護されているmac bookはUSBデバイスの停止で済みましたがWindowsラップトップはクラッシュしました。
通常片側ずつ接続する、ホットプラグしないよう注意が必要です。
正しく修正できたら更新します。

I2Cの信号線はプルアップが必要です。
プルアップとは、IC等がその信号線を制御していない場合の電位をビット表現で1に固定するための回路上の処置です。
I2Cの通信プロトコルではSDA、SCLがともに1のとき通信路が使われていないと決まっています。
逆に、誰も使っていないにもかかわらず勝手にSCLやSDAが0になってしまうと未使用にもかかわらず使用中に見え、だれにも使えない状態になってしまいます。
ICが停止していたり接続されていない場合は常に1になるべきです。
このための回路上の処置を、電位を引き上げるという意味でプルアップといいます。

![i2c-pull-up](i2c-pull-up.png)

プルアップの仕方は簡単で、適切な大きさの抵抗をVCCと信号線の間にいれるだけです。
VCCと信号線の間が接続されるので、誰も線に接続していないときはVCCと同じ電位になります。
誰かが制御しているときは抵抗が入っているためVCCに引っ張り上げられることはありません。
抵抗値の計算を正しくやるためには回路のキャパシタンスを求める必要がありますが、利用者がケーブルを使うかもわからないで計算できるわけもないので、適当に決めます。
I2CのStandard mode(100kHz)の場合4.7kΩという値がよくでます(例: [Sparkfun tutorial](https://learn.sparkfun.com/tutorials/i2c/i2c-at-the-hardware-level))。
今回は手元に余っていた抵抗を適当に使いました。
抵抗値が低すぎるとVCCに引きずられ信号レベルがただしく0にならない、抵抗値が高すぎると信号の切り替わりが遅くなり意図せず前の信号を読んでしまうリスクがあります。
特にI2CをFast mode(400kHz)で使いたい場合は抵抗値を1/5程度に下げないといけないようです。
詳しくは[I2C Bus Pull-Up Resistor Calculation (PDF)](https://www.ti.com/lit/an/slva689/slva689.pdf)などを確認してください。

## BOOTやデバッグ

開発ボードを利用する場合は開発ボードがよいかんじに設計されているのであまり気にしませんが、MCUを直接取り扱う時はブートモードの切り替えやデバッグ手段についても考えて基板設計する必要があります。
MCUの選定の箇所でDFUとデバッグサポートを紹介しました。
この節では実際にこれらの機能を利用するためのハードウェア上の準備を確認します。

まずデバッグサポートはいちばん必要なピン数がすくないSerial wire JTAG debug port (SWJ-DP)を利用します。
STM32L412ではSWDIO(PA13)とSWCLK(PA14)にST-Link等のデバッグハードウェアを接続しJTAGが利用できます。
STM32のMCUのほとんどで同機能が提供されています。
あとからMCU上のピンにデバッグハードウェアを接続するのは大変なので、この2ピンもMountingHoleで取り出しておきます。
VCC、GNDとあわせ、基板上の結線しやすい場所に穴を配置しましょう。

![swjdp](swjdp.png)

実際にデバッグするときはジャンパワイヤ等を直接はんだ付けして利用します。

![swjdp-usage](swjdp-usage.jpg)

最後にBOOTです。
再度AN2606やデータシートを確認し、DFUに入るための条件を確認しましょう。
SWJ-DPがあれば最悪そこからファームウェアを書き換えられますが、通常利用時に毎回ST-Linkを接続するのはとても面倒です。
STM32は一般に何も設定していない状態でのブートはユーザが書き込んだファームウェアがあればそれをブートする、なければシステムファームウェアをブートするとなっているようです。
USB接続状態でシステムファームウェアがブートされるとDFUが起動します。

逆に、一度ユーザファームウェアを書き込んでしまうと次からシステムファームウェアに入るためになんらかの工夫が必要です。
STM32L412にはBOOT0というピンを制御する方法とnSWBOOT0というオプションビットを制御する方法があります。
BOOT0ピンは物理的にスイッチなどで制御します。
具体的にはリセットボタンを押す→BOOT0を押す→リセットを離す→BOOT0を離すと操作するとBOOT0が押下された状態で起動され、システムファームウェアに入ります。
nSWBOOT0オプションビットはプログラムやJTAGから変更可能な内部レジスタにあります。
プログラムでこのビットを制御してからリセットをかけることでもシステムファームウェアに入れます。
キー操作でDFU待ち受け状態にしたいときに利用できます。

nSWBOOT0を書き換えるプログラムがうまく動作しないとシステムファームウェアに戻れなくて詰むので、BOOT0もアクセスできるようにしておきましょう。
普段使わない想定ならばMountingHoleをつくっておくだけでもよいですが、わたしは特に開発初期に頻繁に使うと予想し物理スイッチを配置しました。

![nrst-boot0](nrst-boot0.png)
![boot0-button](boot0-button.png)

nRSTはLOWでON、BOOT0はHIGHでONです。
nRSTはスイッチを押していないときVCC電位、押しているときGND電位になるべきです。BOOT0は逆です。
回路はnRSTはプルアップしスイッチの先をGNDに接続、BOOTは逆にプルダウンしスイッチの先をVCCに接続します。

# 基板の作成

# 基板の実装
