第三章では、第二章で扱ったハードウェアの実装を念頭に、作成した基板をキーボードとして動作させるためのソフトウェアの実装方法を紹介します。
例として第二章で取り上げた構成やMCUを使いますが、他の構成でも利用可能な情報になるよう気をつけました。
リファレンスマニュアルやデータシートを参照している箇所はそれぞれお使いのMCUの情報に読み替えてください。

# 環境構築

今後の節ではMCUプログラミングを基礎から解説していきます。
実際に手元のデバイスで実験するために先に環境構築を済ませてしまいましょう。
イマイチ原理や目的がわからない部分もあるだろうと思いますが、ガイダンスに沿ってセットアップしてみてください。

ソフトウェアはすべてLinux、macOS、Windowsで共通のものが使えます。
ダウンロード・インストール方法が異なるものは適宜読み替えてください。

## Rust

Rust言語で実装したファームウェアをコンパイルするために必要です。
[Install Rust](https://www.rust-lang.org/tools/install)の手順にそってインストールしてください。
完了後、`rustup`と`cargo`が使えることを確認してください。
`cargo`はRustのパッケージマネージャ兼ビルドシステムです。

## [cargo-binutils](https://github.com/rust-embedded/cargo-binutils)

cargoのサブコマンドを追加しdfu-utilで書き込み可能なバイナリファイルを作成するために必要です。
[ReadmeのInstallation](https://github.com/rust-embedded/cargo-binutils#installation)に従ってインストールしてください。
あとでCargoプロジェクトを作成してから`cargo objcopy`が実行できれば成功です。

## ARMターゲット

利用するMCUのアーキテクチャに対応したコードを出力するために、ターゲットを追加する必要があります。
ここで指定する引数はMCUによって異なります。
[Crate cortex_m_quickstart](https://docs.rust-embedded.org/cortex-m-quickstart/cortex_m_quickstart/#usage)によると

- Use thumbv6m-none-eabi for ARM Cortex-M0 and Cortex-M0+
- Use thumbv7m-none-eabi for ARM Cortex-M3
- Use thumbv7em-none-eabi for ARM Cortex-M4 and Cortex-M7 (no FPU support)
- Use thumbv7em-none-eabihf for ARM Cortex-M4F and Cortex-M7F (with FPU support)

という対応関係のようです。
[STM32L412](https://www.st.com/en/microcontrollers-microprocessors/stm32l412kb.html)のページに「Ultra-low-power with FPU Arm Cortex-M4 MCU 80 MHz with 128 Kbytes of Flash memory, USB」とありますので、Cortex-M4Fになります。
なおFPUとはFloating Point Unit、浮動小数点演算器です。
利用したMCUのページを確認して必要なものを次のように追加します。

```
rustup target add thumbv7m-none-eabi
```

## dfu-util

USB DFUを使ってファームウェアを書き込むために必要です。
[dfu-util公式サイト](http://dfu-util.sourceforge.net/)でバイナリが配布されています。
macOSであればhomebrewで、UbuntuなどはOSのパッケージマネージャでもインストールできます。

## openocd (ST-Link利用時のみ)

ST-Linkを利用してデバッグする場合、ホストコンピュータとST-Linkの通信に必要です。
[入手方法](http://openocd.org/getting-openocd/)を参考にインストールしてください。
Windows以外では標準的なパッケージマネージャで提供されているようです。
Windowsはコンパイル済バイナリがインターネットに転がっています。

## gdb (ST-Link利用時のみ)

ST-Linkを利用してデバッグする場合、openocdを経由してプログラムをロードしたりデバッグするのに利用します。
ホストコンピュータのアーキテクチャ用のものではなく、MCUのアーキテクチャ用のものが必要です。
[GNU Arm Embedded Toolchain Downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads)から入手できます。
また標準的なパッケージマネージャでも提供されているようです。

## 最初のプロジェクト

(TODO)

# MCUをプログラミングするとは

ソフトウェアを実装するにあたり、どんな仕組みでMCUをプログラミングできるのか理解しておくことが重要です。
コピーペーストでもHello World相当のプログラムを動かすのは簡単ですが、自分のためのキーボードを工夫するには基礎知識があったほうがよいでしょう。
この節ではリファレンスマニュアルを読んだり、プログラミングを進める時に何をやっているのか理解できるだけの背景知識をお伝えします。
やりたいこと、リファレンスマニュアルの情報、Rustのコードを対応づけ、意味がわかりやすいようにしました。
すでにコンピュータサイエンスとSoCの基礎を理解している場合は飛ばしてもかまいません。

## 最も簡単なプログラム

最も簡単な、けれども動作していると分かるプログラムを考えてみましょう。
代表的なのはLチカ(blink)です。
しかしこの文書のトピックはキーボードですから、ボタン入力も受け取りたいです。
まずはボタン入力を受け取り、LEDを光らせるものを作ってみましょう。
自分の基板にLEDがない場合、適当なパッドとGNDにはんだ付けしてしまえばOKです。
あとで取り外せば支障ありません。

(TODO:写真)

次のようなプログラムを実装します。

```
ボタンが押されているか？
押されていたらLEDを光らす、押されていなかったら消す。
```

とっても簡単そうにみえます。
この機能のためにMCUの中でどんな動作が起きているか理解するには手頃なサイズの課題でしょう。

まずこの機能を実現する方法をMCUの視線で考えます。
この段階ではまだ自然言語で表現されます。
MCUの用語を使って表現し直してみましょう。

ボタンが押されているか知る、LEDのON、OFFを制御するなどのインタラクションはGPIO(General Purpose Input Output)をつかって行います。
基板を設計する段階でキースイッチの2端子のうち少なくとも一方はGPIOに接続するよう配線されているでしょう。
Nucleoなど開発ボードを利用している場合はマニュアルを読んでGPIOとして使えるピンにボタンとLEDを接続してください。
仮にボタンがPA0、LEDがPB2に繋がっているとします。
またボタンもLEDも反対側の足はGNDに繋がっているとします。
VCCに繋がっている場合はHIGHとLOWを逆に読み替えてください。
基板をスイッチマトリクス式に設計した場合は反対の線をLOWにしてください。

最初の案をMCUの用語で書くと次のようになります。
ボタンはONのとき反対側のGNDとおなじ電位になるのでLOWになります。
LEDはONにしたいとき反対側のGNDより十分高い電位にするのでHIGHにしたいです。

```
PA0がLOWか？
LOWならPB2をHIGHにする、HIGHならPB2をLOWにする。
```

HIGH/LOWが真偽値とみなせることを利用すると

```
PB2のHIGH/LOWをPA0のHIGH/LOWの反対の状態にする。
```

とまとめられます。
このプログラムを書くことを目指します。

Rustプログラムを書く前に、データシートとマニュアルを読みこの条件を机上で考えてみましょう。

[RM0394 (PDF)](https://www.st.com/resource/en/reference_manual/dm00151940-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)のChapter 8がGPIOに関する章です。
たくさん説明が書いてありますが、ひとまず読み飛ばして8.4 GPIO Registersまで進みます。
さらに下っていくと

> 8.4.5 GPIO port input data register (GPIOx_IDR) (x = A to E and H)

という部分があります。
input dataとありますから、この部分を使えばボタンにつながるGPIOの状態を受け取ることができそうです。
またその次には

> 8.4.6 GPIO port output data register (GPIOx_ODR) (x = A to E and H)

とあります。
output dataはGPIOの値を設定しLEDにつながるGPIOを制御できそうです。

## MCUの仕組み

register(レジスタ)という概念がでてきました。
レジスタとはMCUの仕組みの一部です。
よいタイミングなので、レジスタを説明しつつ、ほかのMCUの最も根本的な仕組みも解説します。
すこし概念的な話になります。

MCUは単機能しかもたないICと異なり、プログラムを書き換えて様々な動作を実現します。
どうしてそんなことができるかというと、MCUが実行する処理を変更できるからです。
実行する処理の指定を命令(instruction)、使える命令をまとめたものを命令セット(instruction set)と呼びます。


MCU、より一般に現在流通しているほとんどのCPUを動かすにはレジスタとメモリが必要です。

## 簡単なプログラムを完成させる

これを[STM3L4 Crate](https://lib.rs/crates/stm32l4)をつかったRustプログラムでは次のように表現します。


```
(TODO: 検証)
// import crate
use stm32l4::stm32l4x1;

// Create interface object of peripherals
let mut peripherals = stm32l4x1::Peripherals::take().unwrap();
// Get GPIO A accessor
let gpioa = &peripherals.GPIOA;
// Get GPIO B accessor
let gpiob = &peripherals.GPIOB;

if (gpioa.idr.read().idr0().is_bit_set()) {
  gpiob.odr.modify(|_, w| w.odr2().clear_bit());
} else {
  gpiob.odr.modify(|_, w| w.odr2().set_bit());
}

// Or
let is_on = gpioa.idr.read().idr0().is_bit_set();
gpiob.odr.modify(|_, w| w.odr2().bit(!is_on));
```



## プログラムを書き込む

# ライブラリの紹介
# 枠組みの実装
